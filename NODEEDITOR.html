<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Programmable Arithmetic Node Editor</title>

    <style>
        * { box-sizing: border-box; }

        body {
            margin: 0;
            height: 100vh;
            font-family: "Poppins", Arial, sans-serif;
            background: radial-gradient(circle at top, #1f2933, #020617);
            color: #e5e7eb;
            display: flex;
            justify-content: center;
            align-items: stretch;
        }

        #app {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        header {
            height: 56px;
            padding: 0 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(15,23,42,0.95);
            border-bottom: 1px solid rgba(148,163,184,0.25);
            backdrop-filter: blur(10px);
        }
        header .title {
            font-size: 18px;
            font-weight: 600;
        }
        header .subtitle {
            font-size: 12px;
            opacity: 0.8;
        }

        footer {
            height: 34px;
            padding: 0 18px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            background: rgba(15,23,42,0.92);
            border-top: 1px solid rgba(148,163,184,0.2);
            font-size: 12px;
            color: #9ca3af;
        }

        #main {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Sidebar */
        #leftPanel {
            width: 230px;
            background: rgba(15,23,42,0.96);
            border-right: 1px solid rgba(148,163,184,0.25);
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .panel-heading {
            font-size: 14px;
            font-weight: 600;
            opacity: 0.85;
            margin-bottom: 4px;
        }

        .node {
            background: rgba(30,64,175,0.12);
            border: 1px solid rgba(96,165,250,0.4);
            border-radius: 12px;
            padding: 10px;
            text-align: center;
            cursor: grab;
            font-size: 14px;
            font-weight: 500;
            color: #dbeafe;
            transition: 0.15s;
        }
        .node:hover {
            transform: scale(1.05);
            box-shadow: 0 0 14px rgba(59,130,246,0.5);
            background: rgba(37,99,235,0.22);
        }

        #runButton {
            margin-top: auto;
            padding: 10px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            background: linear-gradient(135deg,#22c55e,#16a34a);
            color: white;
            box-shadow: 0 0 14px rgba(34,197,94,0.4);
            transition: 0.15s;
        }
        #runButton:hover {
            transform: translateY(-1px) scale(1.03);
            box-shadow: 0 0 18px rgba(34,197,94,0.7);
        }

        /* Canvas */
        #rightPanel {
            flex: 1;
            position: relative;
            overflow: auto;
            background: radial-gradient(circle at top, #020617, #020617 40%, #000);
        }

        svg#connectionLayer {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            overflow: visible;
            z-index: 0;
        }

        .connector-path {
            stroke: #38bdf8;
            stroke-width: 3;
            fill: none;
            stroke-linecap: round;
            stroke-dasharray: 8 6;
            animation: dashMove 1.2s linear infinite;
        }

        @keyframes dashMove {
            to { stroke-dashoffset: -40; }
        }

        /* Nodes on canvas */
        .droppedNode {
            position: absolute;
            min-width: 170px;
            background: rgba(15,23,42,0.92);
            border-radius: 14px;
            border: 1px solid rgba(148,163,184,0.5);
            box-shadow: 0 12px 30px rgba(15,23,42,0.9);
            padding: 10px 12px 12px;
            cursor: grab;
            z-index: 2;
            backdrop-filter: blur(10px);
            transition: box-shadow 0.2s, border-color 0.2s, transform 0.1s;
        }
        .droppedNode:hover {
            border-color: #60a5fa;
            box-shadow: 0 0 18px rgba(37,99,235,0.7);
        }
        .droppedNode-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        .droppedNode-title {
            font-size: 13px;
            font-weight: 600;
            color: #bfdbfe;
        }
        .droppedNode-type {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 999px;
            background: rgba(55,65,81,0.9);
            color: #e5e7eb;
        }
        .droppedNode-body {
            position: relative;
            padding-top: 4px;
        }

        input, textarea {
            width: 100%;
            border-radius: 8px;
            border: 1px solid rgba(55,65,81,0.8);
            background: rgba(15,23,42,0.9);
            color: #e5e7eb;
            padding: 7px 8px;
            font-size: 13px;
            outline: none;
        }
        input:focus, textarea:focus {
            border-color: #60a5fa;
            box-shadow: 0 0 0 1px rgba(37,99,235,0.7);
        }
        textarea {
            resize: none;
            height: 60px;
            font-family: "JetBrains Mono", monospace;
            font-size: 12px;
        }

        .output-display {
            margin-top: 4px;
            min-height: 28px;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid rgba(34,197,94,0.4);
            background: rgba(22,163,74,0.06);
            color: #22c55e;
            font-weight: 700;
            font-size: 14px;
            text-align: center;
        }

        /* Ports */
        .port {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: radial-gradient(circle,#e0f2fe,#38bdf8);
            border: 2px solid #0f172a;
            position: absolute;
            cursor: crosshair;
            box-shadow: 0 0 8px rgba(56,189,248,0.9);
        }

        .port-label {
            position: absolute;
            font-size: 10px;
            color: #9ca3af;
            white-space: nowrap;
            pointer-events: none;
        }

        .port-output {
            right: -8px;
            top: 50%;
            transform: translateY(-50%);
        }
        .port-output + .port-label {
            right: -52px;
            top: 50%;
            transform: translateY(-50%);
        }

        .port-input {
            left: -8px;
            top: 50%;
            transform: translateY(-50%);
        }
        .port-input + .port-label {
            left: -55px;
            top: 50%;
            transform: translateY(-50%);
            text-align: right;
        }
    </style>
</head>
<body>
<div id="app">
    <header>
        <div>
            <div class="title">Programmable Arithmetic Node Editor</div>
            <div class="subtitle">Connect input â†’ function â†’ output and run your custom logic</div>
        </div>
    </header>

    <div id="main">
        <div id="leftPanel">
            <div class="panel-heading">Node Types</div>
            <div class="node" draggable="true" data-type="input">ðŸ”¢ Input Node</div>
            <div class="node" draggable="true" data-type="function">ðŸ§  Function Node</div>
            <div class="node" draggable="true" data-type="output">ðŸ“¤ Output Node</div>
            <button id="runButton">â–¶ Run Graph</button>
        </div>

        <div id="rightPanel">
            <svg id="connectionLayer"></svg>
        </div>
    </div>

    <footer>
        Built by <strong style="margin-left:4px;">CHANDAN KUMAR K</strong>
    </footer>
</div>

<script>
    let nodeCounter = 0;
    let connections = [];
    let currentStartPort = null;
    let tempPath = null;

    const rightPanel = document.getElementById('rightPanel');
    const connectionLayer = document.getElementById('connectionLayer');
    const runButton = document.getElementById('runButton');

    // sidebar drag source
    document.querySelectorAll('.node').forEach(node => {
        node.addEventListener('dragstart', e => {
            e.dataTransfer.setData('nodeType', e.target.dataset.type);
        });
    });

    rightPanel.addEventListener('dragover', e => e.preventDefault());

    rightPanel.addEventListener('drop', e => {
        e.preventDefault();
        const type = e.dataTransfer.getData('nodeType');
        if (!type) return;
        const rect = rightPanel.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const nodeEl = createNode(type, x, y);
        rightPanel.appendChild(nodeEl);
        nodeCounter++;
    });

    function createNode(type, x, y) {
        const node = document.createElement('div');
        node.className = 'droppedNode';
        node.style.left = x + 'px';
        node.style.top = y + 'px';
        node.dataset.nodeId = String(nodeCounter + 1);
        node.dataset.type = type;

        let titleText = '';
        let typeLabel = '';
        let bodyHtml = '';

        if (type === 'input') {
            titleText = 'Input Node';
            typeLabel = 'INPUT';
            bodyHtml = `
                <div class="droppedNode-body">
                    <div class="port port-output" data-port-role="output"></div>
                    <div class="port-label">OUTPUT</div>
                    <input type="number" placeholder="Enter value" oninput="runNodes()" />
                </div>`;
        } else if (type === 'function') {
            titleText = 'Function Node';
            typeLabel = 'LOGIC';
            bodyHtml = `
                <div class="droppedNode-body">
                    <div class="port port-input" data-port-role="input"></div>
                    <div class="port-label">INPUTS</div>
                    <div class="port port-output" data-port-role="output"></div>
                    <div class="port-label">RESULT</div>
                    <textarea placeholder="inputs.reduce((a,b)=>a+b,0)" oninput="runNodes()"></textarea>
                </div>`;
        } else if (type === 'output') {
            titleText = 'Output Node';
            typeLabel = 'OUTPUT';
            bodyHtml = `
                <div class="droppedNode-body">
                    <div class="port port-input" data-port-role="input"></div>
                    <div class="port-label">INPUT</div>
                    <div class="output-display"></div>
                </div>`;
        }

        node.innerHTML = `
            <div class="droppedNode-header">
                <div class="droppedNode-title">${titleText}</div>
                <div class="droppedNode-type">${typeLabel}</div>
            </div>
            ${bodyHtml}
        `;

        makeDraggable(node);
        return node;
    }

    function makeDraggable(node) {
        let offsetX = 0, offsetY = 0, startX = 0, startY = 0;

        node.addEventListener('mousedown', e => {
            if (e.target.classList.contains('port') ||
                e.target.tagName === 'INPUT' ||
                e.target.tagName === 'TEXTAREA') {
                return;
            }
            e.preventDefault();
            startX = e.clientX;
            startY = e.clientY;
            offsetX = node.offsetLeft;
            offsetY = node.offsetTop;

            function onMove(ev) {
                const dx = ev.clientX - startX;
                const dy = ev.clientY - startY;
                node.style.left = offsetX + dx + 'px';
                node.style.top = offsetY + dy + 'px';
                updateAllConnections();
            }

            function onUp() {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
            }

            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        });
    }

    // Port-based connecting
    rightPanel.addEventListener('mousedown', e => {
        const port = e.target;
        if (!port.classList.contains('port')) return;
        if (!port.classList.contains('port-output')) return; // start only from output

        currentStartPort = port;
        const start = getPortCenter(port);

        tempPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        tempPath.setAttribute('class', 'connector-path');
        connectionLayer.appendChild(tempPath);

        function onMove(ev) {
            const panelRect = rightPanel.getBoundingClientRect();
            const x2 = ev.clientX - panelRect.left;
            const y2 = ev.clientY - panelRect.top;
            drawPath(tempPath, start.x, start.y, x2, y2);
        }

        function onUp(ev) {
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);

            const target = ev.target;
            if (target.classList.contains('port-input')) {
                const startNode = currentStartPort.closest('.droppedNode');
                const endNode = target.closest('.droppedNode');
                if (startNode && endNode && startNode !== endNode) {
                    const connId = 'c_' + Date.now() + '_' + Math.random().toString(16).slice(2);
                    const conn = {
                        id: connId,
                        fromNodeId: startNode.dataset.nodeId,
                        toNodeId: endNode.dataset.nodeId,
                        pathEl: tempPath
                    };
                    connections.push(conn);
                    tempPath.dataset.connectionId = connId;
                    updateAllConnections();
                    runNodes();
                    tempPath = null;
                    currentStartPort = null;
                    return;
                }
            }
            // invalid target â†’ remove temp line
            if (tempPath) {
                tempPath.remove();
                tempPath = null;
            }
            currentStartPort = null;
        }

        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
    });

    function getPortCenter(portEl) {
        const pr = rightPanel.getBoundingClientRect();
        const r = portEl.getBoundingClientRect();
        return {
            x: r.left + r.width / 2 - pr.left,
            y: r.top + r.height / 2 - pr.top
        };
    }

    function drawPath(pathEl, x1, y1, x2, y2) {
        const dx = (x2 - x1) * 0.4;
        const d = `M${x1},${y1} C${x1+dx},${y1} ${x2-dx},${y2} ${x2},${y2}`;
        pathEl.setAttribute('d', d);
    }

    function updateAllConnections() {
        connections.forEach(conn => {
            const fromNode = document.querySelector(`.droppedNode[data-node-id="${conn.fromNodeId}"]`);
            const toNode = document.querySelector(`.droppedNode[data-node-id="${conn.toNodeId}"]`);
            if (!fromNode || !toNode) return;
            const fromPort = fromNode.querySelector('.port-output');
            const toPort = toNode.querySelector('.port-input');
            if (!fromPort || !toPort) return;
            const p1 = getPortCenter(fromPort);
            const p2 = getPortCenter(toPort);
            drawPath(conn.pathEl, p1.x, p1.y, p2.x, p2.y);
        });
    }

    // Execution
    function runNodes() {
        const functionNode = document.querySelector('.droppedNode[data-type="function"]');
        if (!functionNode) return;

        const fnId = functionNode.dataset.nodeId;
        const inputConnections = connections.filter(c => c.toNodeId === fnId);

        const inputs = [];
        inputConnections.forEach(conn => {
            const inputNode = document.querySelector(`.droppedNode[data-node-id="${conn.fromNodeId}"]`);
            if (inputNode && inputNode.dataset.type === 'input') {
                const val = parseFloat(inputNode.querySelector('input').value) || 0;
                inputs.push(val);
            }
        });

        const code = (functionNode.querySelector('textarea').value || '').trim();
        let result;
        try {
            const fn = new Function('inputs', `return ${code || 'inputs.reduce((a,b)=>a+b,0)'}`);
            result = fn(inputs);
        } catch (e) {
            result = 'Error';
        }

        const outputNodes = document.querySelectorAll('.droppedNode[data-type="output"]');
        outputNodes.forEach(outNode => {
            const hasConn = connections.some(c => c.fromNodeId === fnId && c.toNodeId === outNode.dataset.nodeId);
            if (hasConn) {
                const disp = outNode.querySelector('.output-display');
                disp.textContent = result;
            }
        });
    }

    runButton.addEventListener('click', runNodes);
</script>
</body>
</html>
